# Deploy Application in Kubernetes

_This scenario is a prereq scenerio. It is not mandatory for the other scenerios. It will show you how to deploy the task-service application in Kubernetes. It will walk through building a container from a Dockerfile. Pushing the container into a Container Reguistry (DockerHub in this case), deploying the application into kubernetes, and exposing a service to the outside world and clean it up when done._

## Prereqs

- Docker for Desktop with Kubernetes Enabled
- kubectl


```
$ kubectl version
Client Version: version.Info{Major:"1", Minor:"20", GitVersion:"v1.20.0", GitCommit:"af46c47ce925f4c4ad5cc8d1fca46c7b77d13b38", GitTreeState:"clean", BuildDate:"2020-12-13T19:50:45Z", GoVersion:"go1.15.5", Compiler:"gc", Platform:"darwin/amd64"}
Server Version: version.Info{Major:"1", Minor:"19", GitVersion:"v1.19.3", GitCommit:"1e11e4a2108024935ecfcb2912226cedeafd99df", GitTreeState:"clean", BuildDate:"2020-10-14T12:41:49Z", GoVersion:"go1.15.2", Compiler:"gc", Platform:"linux/amd64"}
```

## Overview

- [Create a container](#create-a-container)
- [Push container to image registry](#push-container-to-image-registry) 
- [Create a Kubernetes deployment using `kubectl`](#create-a-kubernetes-deployment-using-kubectl)
- [Create a Kubernetes Service using `kubectl`](#create-a-kubernetes-service-using-kubectl)
- [Test the application](#test-the-application)
- [Cleanup](#cleanup)

## Create a container

The very first part of the deployment of `task-service` is to build a container from the source code. Notice that we have a `Dockerfile` in the root of the application. We will build the image and ue the following naming convention: [container-registry]/[username]/[app-name].

- [container-registry] is the container registry where you are going to push your image, `docker.io` or `quay.io` are a couple of options
- [username] is your username for the container registry (mine is cmwylie19)
- [app-name] is the name of your image (ours will be `task-service`)

```
docker build -t docker.io/cmwylie19/task-service .
```

We can find the build container by searching for it in our local docker registry:
```
docker image ls cmwylie19/task-service
```

## Push Container to Image Registry
The next step for us is to push the container that we built locally to [DockerHub](hub.docker.com). You *must* have an account to complete this section.  

First thing we need to do is login to dockerhub from the command line.
```
docker login 
```

After logging in, the next step is to push the container from the local docker reigstry to DockerHub.

```
docker push docker.io/cmwylie19/task-service 
```


## Create a Kubernetes Deployment using kubectl
A quick and simple way to create a deployment is using `kubectl`. 
We simply need to create a name for the deployment, in this case, task-service, and point to the image from which we want to create the deployment, in this case `docker.io/cmwylie19/task-service`.

```
kubectl create deployment task-service --image=docker.io/cmwylie19/task-service:latest
```

Verify your deployment is up and available with:

```
kubectl get deployments task-service
```

According to devops best practices you should always export your configuration as code. The way to export the deployment to yaml is:

```
kubectl get deployments task-service -o yaml > deployment-taskservice.yaml
```

Now that you have exported the deployment to yaml, you will need to sanitize it, which means getting rid of the unnecessary autogenerated fields:
- status
- metadata.annotations
- metadata.creationTimestamp
- metadata.generation
- metadata.managedFields
- metadata.uid
- metadata.selfLink
- metadata.resourceVersion
- spec.template.metadata.creationTimestamp




## Create a service

Now that we have our deployment created, we can expose a service from it. We will use `kubectl expose`, and give the service a type `LoadBalancer` which indicates that we are exposing our service outside of the cluster through a load balancer.

```
kubectl expose deployment task-service --type=LoadBalancer --port=8080
```

Check the status of the service with the following command:

```
kubectl get svc task-service
```

```
kubectl get svc task-service -o yaml > service-taskservice.yaml
```
Export the Service to yaml and sanitize by removing:
- metadata.ceationTimestamp
- metadata.managedFields
- metadata.resourceVesion
- metadata.uid
- metadata.selfLink
- status 

**Note**- We exposed the `task-service` type as `LoadBalancer`, in future scenarios the type will be using type `ClusterIP`, which exposes the Service on a cluster-internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default, and makes sense because we will use Gloo Edge to talk to our Kubernetes Service

## Test the application

Now that we have create a service of type LoadBalancer we can try and curl our application to test:

Lets create a task:

```
curl -X POST -H "Content-Type: application/json" -d '{"name":"test"}' http://localhost:8080/create
```
expected output should resemble the output below, with a different id:
```
Created{
  "id": "18f5a03088a",
  "name": "test",
  "complete": false
}%  
```

If you received a similar output then you are on the right track! 

## Clean Up

Now we will clean up the deployment and the service. We will use them again in other scenarios but we will deploy them from yaml when we do.

Delete the deployment and Service:

```
kubectl delete deployment,svc task-service
```
